/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package org.dlect.ui.prefs.subject;

import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;
import java.awt.Color;
import java.awt.Font;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.util.Map;
import java.util.Set;
import javax.swing.BorderFactory;
import javax.swing.JLabel;
import javax.swing.SwingConstants;
import org.dlect.controller.MainController;
import org.dlect.controller.worker.download.DownloadErrorDisplayable;
import org.dlect.controller.worker.download.PreconfiguredSubjectDownloader;
import org.dlect.events.Event;
import org.dlect.events.EventListener;
import org.dlect.events.wrapper.Wrappers;
import org.dlect.exception.DLectExceptionCause;
import org.dlect.model.Lecture;
import org.dlect.model.Subject;
import org.dlect.model.Subject.SubjectEventID;
import org.dlect.model.formatter.DownloadType;

/**
 *
 * @author lee
 */
public class AdvancedLecturePanel extends SubjectPreferencesPanel implements EventListener, DownloadErrorDisplayable {

    private final Subject s;
    private final MainController c;
    private JLabel lectureHeadingLabel;
    private final Map<DownloadType, JLabel> downloadTypeHeadingLabels = Maps.newEnumMap(DownloadType.class);
    private final Map<Lecture, LectureRowHandler> lectureRowMap = Maps.newTreeMap();
    private final PreconfiguredSubjectDownloader psd;

    /**
     * Creates new form AdvancedLecturePanel
     *
     * @param s
     * @param c
     */
    public AdvancedLecturePanel(Subject s, MainController c) {
        super(s, c);
        this.s = s;
        this.c = c;
        this.psd = new PreconfiguredSubjectDownloader(this, c, s);
        initComponents();
        updateSubjectLectures();
        Wrappers.addSwingListenerTo(this, s, Subject.class);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">
    private void initComponents() {
        lectureHeadingLabel = new javax.swing.JLabel();
        final Font labelFont = lectureHeadingLabel.getFont().deriveFont(lectureHeadingLabel.getFont().getSize() + 2f);

        lectureHeadingLabel.setFont(labelFont);
        lectureHeadingLabel.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        lectureHeadingLabel.setText("Lecture");
        lectureHeadingLabel.setBorder(BorderFactory.createMatteBorder(0, 0, 1, 1, Color.BLACK));

        for (DownloadType downloadType : DownloadType.values()) {
            JLabel label = new JLabel(downloadType.toString());
            label.setFont(labelFont);
            label.setHorizontalAlignment(SwingConstants.CENTER);
            label.setBorder(BorderFactory.createMatteBorder(0, 1, 1, 1, Color.BLACK));

            downloadTypeHeadingLabels.put(downloadType, label);
        }
        setLayout(new GridBagLayout());
        addComponents();
    }

    private void addComponents() {
        GridBagConstraints gridBagConstraints;
        gridBagConstraints = new GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = GridBagConstraints.NORTHWEST;
        gridBagConstraints.weightx = 1.0;
        add(lectureHeadingLabel, gridBagConstraints);
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.weightx = 0;
        for (JLabel label : downloadTypeHeadingLabels.values()) {
            add(label, gridBagConstraints);
            gridBagConstraints.gridx += 2;
        }
    }

    private void updateSubjectLectures() {
        ImmutableSortedSet<Lecture> lectures = s.getLectures();
        Set<Lecture> toRemove = Sets.newHashSet(lectureRowMap.keySet());
        toRemove.removeAll(lectures);
        for (Lecture l : toRemove) {
            lectureRowMap.remove(l).removeFromLayout(this);
        }
        int row = 0;
        for (Lecture l : lectures) {
            LectureRowHandler get = lectureRowMap.get(l);
            if (get == null) {
                get = new LectureRowHandler(psd, c.getControllerStateHelper(), s, l);
                lectureRowMap.put(l, get);
                get.createItems();
            }
            GridBagConstraints gbc = new GridBagConstraints();
            gbc.gridy = 1 + row;
            get.doLayout(this, gbc);

            row++;
        }
    }

    @Override
    public void processEvent(Event e) {
        if (e.getEventID().equals(SubjectEventID.LECTURE)) {
            updateSubjectLectures();
        }
    }

    @Override
    public void showDownloadError(Subject subject, Lecture lecture, DownloadType downloadType, DLectExceptionCause failureCause) {
        // TODO error.
    }
    
    

    @Override
    public void doPreShow() {
        // TODO write pre show method.
    }

    @Override
    public String getTabName() {
        return "Lectures";
    }

    @Override
    public String getTabTooltip() {
        return "Download individual lectures";
    }
}
